package storage

import (
	"fmt"
	"strings"
	"time"

	"github.com/Ananth-NQI/truckpe-backend/internal/models"
	"gorm.io/gorm"
)

// DatabaseStore implements Store interface using PostgreSQL
type DatabaseStore struct {
	db *gorm.DB
}

// NewDatabaseStore creates a new database storage
func NewDatabaseStore(db *gorm.DB) Store {
	return &DatabaseStore{db: db}
}

// Trucker operations
func (d *DatabaseStore) CreateTrucker(reg *models.TruckerRegistration) (*models.Trucker, error) {
	// Check if phone already exists
	var existing models.Trucker
	if err := d.db.Where("phone = ?", reg.Phone).First(&existing).Error; err == nil {
		return nil, fmt.Errorf("phone number already registered")
	}

	// Check if vehicle already exists
	if err := d.db.Where("vehicle_no = ?", reg.VehicleNo).First(&existing).Error; err == nil {
		return nil, fmt.Errorf("vehicle already registered")
	}

	trucker := &models.Trucker{
		Name:        reg.Name,
		Phone:       reg.Phone,
		VehicleNo:   reg.VehicleNo,
		VehicleType: reg.VehicleType,
		Capacity:    reg.Capacity,
		Verified:    false,
		Rating:      5.0, // Start with 5 stars
		TotalTrips:  0,
		Available:   true,
	}

	if err := d.db.Create(trucker).Error; err != nil {
		return nil, fmt.Errorf("failed to create trucker: %w", err)
	}

	return trucker, nil
}

func (d *DatabaseStore) GetTrucker(id string) (*models.Trucker, error) {
	var trucker models.Trucker

	// Check if it's a TruckerID (starts with "TR") or numeric ID
	if strings.HasPrefix(id, "TR") {
		// Search by TruckerID only
		if err := d.db.Where("trucker_id = ?", id).First(&trucker).Error; err != nil {
			if err == gorm.ErrRecordNotFound {
				return nil, fmt.Errorf("trucker not found")
			}
			return nil, fmt.Errorf("database error: %w", err)
		}
	} else {
		// Try to parse as numeric ID
		if err := d.db.Where("id = ?", id).First(&trucker).Error; err != nil {
			if err == gorm.ErrRecordNotFound {
				return nil, fmt.Errorf("trucker not found")
			}
			return nil, fmt.Errorf("database error: %w", err)
		}
	}

	return &trucker, nil
}

func (d *DatabaseStore) GetTruckerByPhone(phone string) (*models.Trucker, error) {
	var trucker models.Trucker
	if err := d.db.Where("phone = ?", phone).First(&trucker).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			return nil, fmt.Errorf("trucker not found")
		}
		return nil, fmt.Errorf("database error: %w", err)
	}
	return &trucker, nil
}

// Load operations
func (d *DatabaseStore) CreateLoad(load *models.Load) (*models.Load, error) {
	// LoadID will be auto-generated by BeforeCreate hook
	load.Status = "available"

	if err := d.db.Create(load).Error; err != nil {
		return nil, fmt.Errorf("failed to create load: %w", err)
	}

	return load, nil
}

func (d *DatabaseStore) GetLoad(id string) (*models.Load, error) {
	var load models.Load

	// Check if it's a LoadID (starts with "LD") or numeric ID
	if strings.HasPrefix(id, "LD") {
		// Search by LoadID only
		if err := d.db.Where("load_id = ?", id).First(&load).Error; err != nil {
			if err == gorm.ErrRecordNotFound {
				return nil, fmt.Errorf("load not found")
			}
			return nil, fmt.Errorf("database error: %w", err)
		}
	} else {
		// Try to parse as numeric ID
		if err := d.db.Where("id = ?", id).First(&load).Error; err != nil {
			if err == gorm.ErrRecordNotFound {
				return nil, fmt.Errorf("load not found")
			}
			return nil, fmt.Errorf("database error: %w", err)
		}
	}

	return &load, nil
}

func (d *DatabaseStore) GetAvailableLoads() ([]*models.Load, error) {
	var loads []*models.Load
	if err := d.db.Where("status = ?", "available").
		Order("created_at DESC").
		Find(&loads).Error; err != nil {
		return nil, fmt.Errorf("failed to fetch loads: %w", err)
	}
	return loads, nil
}

func (d *DatabaseStore) SearchLoads(search *models.LoadSearch) ([]*models.Load, error) {
	query := d.db.Where("status = ?", "available")

	if search.FromCity != "" {
		// Use ILIKE for case-insensitive search in PostgreSQL
		query = query.Where("LOWER(from_city) = LOWER(?)", search.FromCity)
	}
	if search.ToCity != "" {
		query = query.Where("LOWER(to_city) = LOWER(?)", search.ToCity)
	}
	if search.VehicleType != "" {
		query = query.Where("LOWER(vehicle_type) LIKE LOWER(?)", "%"+search.VehicleType+"%")
	}
	if search.DateFrom != "" {
		if date, err := time.Parse("2006-01-02", search.DateFrom); err == nil {
			query = query.Where("loading_date >= ?", date)
		}
	}

	var loads []*models.Load
	if err := query.Order("created_at DESC").Find(&loads).Error; err != nil {
		return nil, fmt.Errorf("failed to search loads: %w", err)
	}
	return loads, nil
}

func (d *DatabaseStore) UpdateLoadStatus(id string, status string) error {
	var result *gorm.DB

	// Check if it's a LoadID (starts with "LD") or numeric ID
	if strings.HasPrefix(id, "LD") {
		result = d.db.Model(&models.Load{}).
			Where("load_id = ?", id).
			Update("status", status)
	} else {
		result = d.db.Model(&models.Load{}).
			Where("id = ?", id).
			Update("status", status)
	}

	if result.Error != nil {
		return fmt.Errorf("failed to update load status: %w", result.Error)
	}
	if result.RowsAffected == 0 {
		return fmt.Errorf("load not found")
	}
	return nil
}

// Booking operations
func (d *DatabaseStore) CreateBooking(loadID, truckerID string) (*models.Booking, error) {
	// Start transaction
	tx := d.db.Begin()
	defer func() {
		if r := recover(); r != nil {
			tx.Rollback()
		}
	}()

	// Get load with proper ID handling
	var load models.Load
	if strings.HasPrefix(loadID, "LD") {
		if err := tx.Where("load_id = ?", loadID).First(&load).Error; err != nil {
			tx.Rollback()
			return nil, fmt.Errorf("load not found")
		}
	} else {
		if err := tx.Where("id = ?", loadID).First(&load).Error; err != nil {
			tx.Rollback()
			return nil, fmt.Errorf("load not found")
		}
	}

	if load.Status != "available" {
		tx.Rollback()
		return nil, fmt.Errorf("load not available")
	}

	// Get trucker with proper ID handling
	var trucker models.Trucker
	if strings.HasPrefix(truckerID, "TR") {
		if err := tx.Where("trucker_id = ?", truckerID).First(&trucker).Error; err != nil {
			tx.Rollback()
			return nil, fmt.Errorf("trucker not found")
		}
	} else {
		if err := tx.Where("id = ?", truckerID).First(&trucker).Error; err != nil {
			tx.Rollback()
			return nil, fmt.Errorf("trucker not found")
		}
	}

	// Create booking using the actual model IDs (not the input parameters)
	now := time.Now()
	booking := &models.Booking{
		LoadID:        load.LoadID,       // Use the actual LoadID from the model
		TruckerID:     trucker.TruckerID, // Use the actual TruckerID from the model
		ShipperID:     load.ShipperID,
		AgreedPrice:   load.Price,
		Commission:    load.Price * 0.05, // 5% commission
		NetAmount:     load.Price * 0.95,
		Status:        models.BookingStatusConfirmed,
		PaymentStatus: models.PaymentStatusPending,
		ConfirmedAt:   &now,
	}

	// BookingID and OTP will be auto-generated by BeforeCreate hook
	if err := tx.Create(booking).Error; err != nil {
		tx.Rollback()
		return nil, fmt.Errorf("failed to create booking: %w", err)
	}

	// Update load status
	if err := tx.Model(&load).Update("status", "booked").Error; err != nil {
		tx.Rollback()
		return nil, fmt.Errorf("failed to update load status: %w", err)
	}

	// Update trucker availability
	if err := tx.Model(&trucker).Update("available", false).Error; err != nil {
		tx.Rollback()
		return nil, fmt.Errorf("failed to update trucker availability: %w", err)
	}

	// Commit transaction
	if err := tx.Commit().Error; err != nil {
		return nil, fmt.Errorf("failed to commit transaction: %w", err)
	}

	return booking, nil
}

func (d *DatabaseStore) GetBooking(id string) (*models.Booking, error) {
	var booking models.Booking

	// Check if it's a BookingID (starts with "BK") or numeric ID
	if strings.HasPrefix(id, "BK") {
		// Search by BookingID only
		if err := d.db.Where("booking_id = ?", id).First(&booking).Error; err != nil {
			if err == gorm.ErrRecordNotFound {
				return nil, fmt.Errorf("booking not found")
			}
			return nil, fmt.Errorf("database error: %w", err)
		}
	} else {
		// Try to parse as numeric ID
		if err := d.db.Where("id = ?", id).First(&booking).Error; err != nil {
			if err == gorm.ErrRecordNotFound {
				return nil, fmt.Errorf("booking not found")
			}
			return nil, fmt.Errorf("database error: %w", err)
		}
	}

	return &booking, nil
}

func (d *DatabaseStore) GetBookingsByTrucker(truckerID string) ([]*models.Booking, error) {
	var bookings []*models.Booking
	if err := d.db.Where("trucker_id = ?", truckerID).
		Order("created_at DESC").
		Find(&bookings).Error; err != nil {
		return nil, fmt.Errorf("failed to fetch bookings: %w", err)
	}
	return bookings, nil
}

func (d *DatabaseStore) GetBookingsByLoad(loadID string) ([]*models.Booking, error) {
	var bookings []*models.Booking
	if err := d.db.Where("load_id = ?", loadID).
		Order("created_at DESC").
		Find(&bookings).Error; err != nil {
		return nil, fmt.Errorf("failed to fetch bookings: %w", err)
	}
	return bookings, nil
}

func (d *DatabaseStore) UpdateBookingStatus(id string, status string) error {
	var result *gorm.DB

	// Check if it's a BookingID (starts with "BK") or numeric ID
	if strings.HasPrefix(id, "BK") {
		result = d.db.Model(&models.Booking{}).
			Where("booking_id = ?", id).
			Update("status", status)
	} else {
		result = d.db.Model(&models.Booking{}).
			Where("id = ?", id).
			Update("status", status)
	}

	if result.Error != nil {
		return fmt.Errorf("failed to update booking status: %w", result.Error)
	}
	if result.RowsAffected == 0 {
		return fmt.Errorf("booking not found")
	}
	return nil
}
